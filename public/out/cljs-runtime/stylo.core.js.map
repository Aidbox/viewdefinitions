{"version":3,"sources":["stylo/core.cljc"],"mappings":";AA+PA","names":[],"sourcesContent":["(ns stylo.core\n  (:require\n   #?(:clj [clojure.string :as str])\n   #?(:clj [stylo.rule :refer [rule join-rules]])\n   #?(:clj [garden.core])\n   #?(:clj [garden.stylesheet])\n   #?(:clj [stylo.tailwind.preflight])\n   #?(:clj [stylo.tailwind.accessibility])\n   #?(:clj [stylo.tailwind.background])\n   #?(:clj [stylo.tailwind.border])\n   #?(:clj [stylo.tailwind.effect])\n   #?(:clj [stylo.tailwind.flex])\n   #?(:clj [stylo.tailwind.grid])\n   #?(:clj [stylo.tailwind.interactivity])\n   #?(:clj [stylo.tailwind.layout])\n   #?(:clj [stylo.tailwind.sizing])\n   #?(:clj [stylo.tailwind.spacing])\n   #?(:clj [stylo.tailwind.svg])\n   #?(:clj [stylo.tailwind.table])\n   #?(:clj [stylo.tailwind.transform])\n   #?(:clj [stylo.tailwind.transition])\n   #?(:clj [stylo.tailwind.typography])\n   #?(:clj [stylo.tailwind.variant])\n   #?(:clj [stylo.util :as u]))\n  #?(:cljs (:require-macros [stylo.core])))\n\n;; TODO refactor -> all in styles\n;; if logic of mediaqueries needs inverting\n;; -> change logic of storing into atom\n;; three atoms -> one atom\n\n;; https://tailwindcss.com/docs/adding-custom-styles#using-arbitrary-values\n#?(:clj\n   (do \n(defonce styles (atom {}))\n(defonce media-styles (atom {}))\n\n(defonce media (atom {:screen {:screen true}\n                      :smartphone {:max-width \"415px\"}\n                      :ereader {:max-width \"481px\"}\n                      :p-tablets {:max-width \"768px\"}\n                      :l-tablets {:max-width \"1025px\"}\n                      :desktop {:min-width \"1200px\"}}))\n\n(defn garden-readable\n  [media-rules]\n  (reduce (fn [acc [f s :as r]]\n            (if (string? f)\n              (conj acc [(keyword f) (second s)])\n              (conj acc r))) [] media-rules))\n\n(defn media-query\n  [media-specs class-name rules]\n  (garden.stylesheet/at-media\n   media-specs\n   [[class-name (-> rules\n                    join-rules\n                    garden-readable)]]))\n\n(defn defmediarules\n  [media]\n  (doseq [[k v] media]\n    (defmethod rule k [_ & rules]\n      (fn [class-name]\n        (media-query v class-name rules)))))\n\n(defmediarules @media)\n\n(defn set-own-mediarules!\n  [rules]\n  (reset! media {})\n  (swap! merge media rules)\n  (defmediarules @media)\n  @media)\n\n(defn extend-media-rules!\n  [rules]\n  (swap! merge media rules)\n  (defmediarules @media)\n  @media)\n\n(defn media-rule?\n  [k]\n  (when (keyword? k)\n    (-> @media\n        keys\n        (->> (apply hash-set)\n             k))))\n\n(defn create-located-classname\n  [env]\n  (when-let [ns-name (get-in env [:ns :name])]\n    (u/format \".%s-%s-%s\"\n              (str/replace ns-name #\"\\.\" \"_\")\n              (:line env)\n              (:column env))))\n\n(defn create-hashed-classname\n  [rules]\n  (->> rules\n       hash\n       (str \".c\")))\n\n(defn create-classname\n  [env rules]\n  (keyword (or (create-located-classname env)\n               (create-hashed-classname rules))))\n\n(defn divide-rules\n  [rules]\n  (reduce (fn [acc r]\n            (cond\n              (keyword? r) (update acc :rules conj r)\n              (-> r first media-rule?) (update acc :media-rules conj r)\n              :else (update acc :rules conj r)))\n          {:rules []\n           :media-rules []} rules))\n\n(defn inject-media-rules\n  [class-name garden-obj]\n  (swap! media-styles dissoc class-name)\n  (swap! media-styles assoc-in [class-name\n                                (-> garden-obj\n                                    :value\n                                    :media-queries)]\n         garden-obj))\n\n(defn create-media-rules\n  [class-name media-rules]\n  (if-not (empty? media-rules)\n    (->> media-rules\n       (mapv (partial apply rule))\n       (mapv (fn [f] (f class-name)))\n       (mapv (fn [g] (inject-media-rules class-name g))))\n    (swap! media-styles dissoc class-name)))\n\n(defn rules-with-location\n  [env rules]\n  (with-meta (join-rules rules)\n    {:location [(:name (:ns env))\n                (:line env)\n                (:column env)]}))\n\n(defn create-rules [env rules]\n  (when-not (empty? rules)\n    (let [class-name (create-classname env rules)]\n      (swap! styles dissoc class-name)\n      (swap! styles assoc\n             class-name\n             (rules-with-location env rules))\n      class-name)))\n\n(defn return-classname\n  [classname]\n  (->> classname\n       str\n       (drop 2)\n       str/join\n       keyword))\n\n(defn c-fn\n  [env rs]\n  (let [{:keys [media-rules rules]} (divide-rules rs)\n        class-name (or (create-rules env rules)\n                       (create-classname env media-rules))\n        _ (create-media-rules class-name media-rules)]\n    (return-classname class-name)))\n\n(defmacro c? [& rs]\n  (let [{:keys [rules media-rules]} (divide-rules rs)\n        class-name (if-not (empty? rules)\n                     (create-classname &env rules)\n                     (create-classname &env media-rules))\n\n        compute-rules (fn [r] (->> r\n                                   join-rules\n                                   (into [class-name])\n                                   garden.core/css\n                                   boolean))\n        compute-media-rules (fn [m] (->> m\n                                         (mapv (partial apply rule))\n                                         (mapv (fn [f] (f class-name)))\n                                         garden.core/css\n                                         boolean))]\n    (cond\n      (and (empty? media-rules)\n           (empty? rules)) true\n      (empty? media-rules) (compute-rules rules)\n      (empty? rules) (compute-media-rules media-rules)\n      :else (and (compute-rules rules)\n                 (compute-media-rules media-rules)))))\n\n(defn prettify [s]\n  (->> s\n       (#(str/replace % #\"\\n\" \"\"))\n       (#(str/replace % #\"\\s{2,}\" \" \"))\n       (reduce (fn [acc v]\n                 (cond (or (= \\{ v)\n                           (= \\} v)) (conj acc v \\newline)\n                       (= \\@ v) (conj acc \\newline \\newline v)\n                       :else (conj acc v)))\n               [])\n       str/join))\n\n(defn css-media-styles\n  ([]\n   (css-media-styles @media-styles))\n  ([media-styles]\n   (->> media-styles\n        vals\n        (mapcat vals)\n        garden.core/css\n        prettify)))\n\n(defn css-rules\n  ([] (css-rules @styles))\n  ([styles]\n   (garden.core/css\n    (concat stylo.tailwind.preflight/preflight\n            (->> styles\n                 (sort-by (comp :location meta))\n                 (mapv (fn [[k v]] (into [k] v))))))))\n\n(defn get-styles\n  []\n  (str (css-rules)\n       (css-media-styles)))\n\n(defmacro mount-style\n  []\n  `(aset (or (.getElementById js/document \"stylo\")\n             (let [style# (.createElement js/document \"style\")]\n               (.setAttribute style# \"id\" \"stylo\")\n               (.appendChild js/document.head style#)\n               style#))\n         \"innerHTML\" ~(get-styles)))\n\n(defn compile-styles\n  ([styles]\n    (str (css-rules styles)))\n  ([styles media-styles]\n    (str (css-rules styles)\n       (css-media-styles media-styles))))))\n\n\n(defmacro c\n  [& rules]\n  #?(:clj (c-fn &env rules)))\n\n(defmacro c-eco\n  \"Uses only hashed version of classname. Is recomended for release purposes, because it minimizes resulting CSS file.\"\n  [& rules]\n  #?(:clj (c-fn nil rules)))\n\n\n(comment\n  (reset! styles {})\n  (reset! media-styles {})\n  @styles\n  @media-styles\n  (get-styles)\n  (c? [:text :blue-300] [:smartphone [:text :blue-500]])\n  (c? [:smartphone [:text :blue-500] {:font-weight \"500\"}]\n      [:screen [:text :pink-200] {:font-weight \"300\"}])\n  (c? [:smartphone [:bg :red-500] [[:.some-arbitrary-class {:bg :blue-400}]]])\n  (c? [:progress-bar [:bg :red-500]] {:font-weight \"500\"})\n  (c? [:progress-bar [:bg :red-500]])\n  (c? [:disabled [:hover [:bg :red-500]]])\n  (c? [:bg :red-500] [[:.some-arbitrary-class {:bg :blue-400}]])\n  (c? [:bg :red-500]\n      [:hover [[:.some-arbitrary-class {:bg :blue-400}]]])\n  (c? [:pseudo \":nth-child(2)\" [:hover [:bg :red-500]]])\n  (c? [[:& {:color \"red\"}]\n       [:&:target {:color \"green\"}]])\n  (c? {:color \"red\"})\n  (c? [:hover [:placeholder :white] [:mb 1]])\n  (c? [:p 1])\n  (c? [:placeholder :white])\n  (c? [:divide-x 2])\n  (c? :sr-only))\n"]}